import six
from sortedcontainers import SortedDict
from collections import defaultdict
from utils import weightJSD, weightGauss, weightLinear
from format import getRangeMiddle


class VocabularyAggregator():
    '''A VocabularyAggregator takes a vocabulary produced by a VocabularyMonitor
    and aggregates them over a set time window. Terms inside the 'window', are
    weighted by a weighting function.

    Keyword arguments:
    weighF          -- Weighting function to be used. Can be 'Gaussian', 'JSD',
                       'Linear' or a custom function (taking two years as
                       its parameters). These weighting functions give more
                       weight to terms from years in the center of the
                       weighting function.
    wfParam         -- Additional parameter for the weighting function
                       (dependent on the function).
    yearsInInterval -- Number of years to be used for each interval (width of
                       the window).
    nWordsPerYear   -- Maximum number of words to be included in each
                       aggregated vocabulary.
    yIntervalFreq   -- Spacing between group periods. TODO: integrate on API
                       and client.
    '''

    def __init__(self, weighF='Gaussian', wfParam=10,
                 yearsInInterval=5, nWordsPerYear=10, yIntervalFreq=None):
        '''Create a VocabularyAggregator.'''
        if yIntervalFreq is None:
            yIntervalFreq = yearsInInterval
        self._weighF = weighF
        self._wfParam = wfParam
        self._yearsInInterval = yearsInInterval
        self._nWordsPerYear = nWordsPerYear
        self._yIntervalFreq = yIntervalFreq

    def aggregate(self, vocab):
        '''Apply the aggrecation algorithm to the given vocabulary with the
        settings for this vocabularyaggregator.

        Returns a dictionary of updated vocabularies and a dictionary of time
        periods which have been aggregated together. The aggregated
        vocabularies have almost the same structure as the vocabularies
        generated by the vocabulary monitor, except keys are the year in the
        center of the time window. E.g.:
            { '1955': [('w1', 1.0), ('w2', 1.0), ...],
              '1958': [('w1', 3.0), ('w3', 2.0), ...]
            }

        Dictionaries of time period aggregations has the year in the center of
        the time window as keys, and a list of originating years as values.
        E.g:
            { '1955': ['1950_1959', '1951_1960', '1952_1961'],
              '1958': ['1953_1962', '1954_1963', '1955_1964']
            }
        '''
        # If vocab is shorter than _yearsInInterval, use all years in vocab
        # in a single interval.
        yrInInterval = min(self._yearsInInterval, len(vocab))
        return _adaptiveAggregation(vocab, n=self._nWordsPerYear,
                                    yIntervals=yrInInterval,
                                    weightF=self._weighF,
                                    param=self._wfParam,
                                    freq=self._yIntervalFreq)


def _adaptiveAggregation(V, n, yIntervals, weightF, param, freq):
    '''Apply adaptive aggregation algorithm to the given vocabulary.'''
    # Initialize returned parameters
    finalVocabs = SortedDict()
    periodGroups = SortedDict()

    # Select weighting function
    f = _selectWeightingFunction(weightF, param)

    # Iterate over time frames
    for t in _arrangeIntervals(V, yIntervals, freq):
        mu_t = getRangeMiddle(t[0], t[-1])
        V_prime = SortedDict({tx: V[tx] for tx in t})

        score = defaultdict(float)
        for years_v, words_v in V_prime.iteritems():
            mu_v = getRangeMiddle(years_v)
            fvt = f(mu_v, mu_t)
            for word, score_wv in words_v:
                score[word] += fvt * score_wv

        # Top n terms w sorted by score_w
        scoreList = [(k, v) for k, v in score.iteritems()]
        scoreList = sorted(scoreList, key=lambda pair: pair[1], reverse=True)
        topN = scoreList[:n]

        finalVocabs[str(int(mu_t))] = topN
        periodGroups[str(int(mu_t))] = t
    return finalVocabs, periodGroups


def _selectWeightingFunction(weightF, param):
    '''Create a weighting function specified by weightF, which uses
    the given parameter param. Returns a function which takes two
    years as inputs: F(Y1, Y2).
    '''
    if weightF == 'Gaussian':
        f = lambda y1, y2: weightGauss(y1, y2, param)
    elif weightF == 'JSD':
        f = lambda y1, y2: weightJSD(y1, y2, param)
    elif weightF == 'Linear':
        f = lambda y1, y2: weightLinear(y1, y2, param)
    elif six.callable(weightF):
        f = weightF
    else:
        raise Exception('Unknown weighting function: ' + weightF)
    return f


def _arrangeIntervals(vocabs, nYears, freq):
    '''Group vocabulary keys in groups of N years. Returns a list of  lists,
    where years are grouped in overlaping sets of nYears. When freq > 1, it
    causes intervals to be spaced every freq years. E.g: For a vocabulary
    spanning years:
    ['1950_1959', '1951_1960', '1952_1961', '1953_1962', '1954_1963']

    Intervals will be:
     [['1950_1959', '1951_1960', '1952_1961'],
      ['1951_1960', '1952_1961', '1953_1962'],
      ['1952_1961', '1953_1962', '1954_1963']]
    '''
    keys = vocabs.keys()
    return [keys[i:i + nYears] for i in range(0, 1 + len(keys) - nYears, freq)]
